#Example of a function under test which produces a random segmentation.
#
#Random segmentation is generated by reading the ground truth segmentation,
#applying a random offset and skew to the ground truth, and fitting the 
#resulting segmentation back to the vessel surface.
#
#Intented to demonstrate rendering of a calculated segmentation.
#
#Function randomMesh can be used in mesh mode
#Function randomVoxel can be used in voxel mode


import numpy as np
import pickle
import math
from scipy import ndimage, linalg
import networkx as nx
from testbench import *


#Example function for use in voxel mode
#
#Returns a numpy array with shape matching the input voxel array containing a bitmask
#representing a random segmentation
#
#To run, use command "py testbench.py examples/example_random.py randomVoxel(filename,point,voxel_array) voxel -r"
def randomVoxel(filename,point,voxel_array):

    #Read true segmentation
    filename = filename.split('\\')[-1].split('.')[0]
    obj = readDataVoxel(filename)

    #Find boundary of true segmentation
    true = np.copy(obj.an_voxelArray26)
    image = np.copy(voxel_array)
    
    k = np.array([[[0,0,0],[0,1,0],[0,0,0]], [[0,1,0],[1,1,1],[0,1,0]], [[0,0,0],[0,1,0],[0,0,0]]])
    conv = ndimage.convolve(image, k, mode='constant', cval=0)
    image[conv==7] = 0
    
    image[true>0] = 0
    k = np.ones((3,3,3))
    image = ndimage.convolve(image, k, mode='constant', cval=0)
    boundary = np.logical_and(true,image)
    
    #Convert boundary to list of voxel coordinates
    boundaryPath = np.argwhere(boundary)
    
    #Find best-fit plane for boundary
    (A,B,C) = linalg.lstsq(np.c_[boundaryPath[:,0],boundaryPath[:,1],np.ones(boundaryPath.shape[0])],boundaryPath[:,2])[0]
    
    #Add randomized offset and skew
    offset = (np.random.rand()*2-1)*obj.anDim.x
    skewA = (1+.1*(np.random.rand()*2-1))
    skewB = (1+.1*(np.random.rand()*2-1))
    #(A,B,C) = (A*skewA, B*skewB, C+offset)
    
    #Select voxels which are on the same side of the new plane as the starting voxel
    newSeg = np.zeros(voxel_array.shape)
    newSeg[tuple(point)] = 2
    k = np.array([[[0,0,0],[0,1,0],[0,0,0]], [[0,1,0],[1,1,1],[0,1,0]], [[0,0,0],[0,1,0],[0,0,0]]])
    conv = ndimage.convolve(voxel_array, k, mode='constant', cval=0)
    surface = np.copy(voxel_array)
    surface[conv==7] = 0
    surface[surface>0] = 1
    (px,py,pz) = (point[0],point[1],point[2])
    ref = np.array([[[0,1,0],[1,1,1],[0,1,0]], [[1,1,1],[1,0,1],[1,1,1]], [[0,1,0],[1,1,1],[0,1,0]]])
    (dx,dy,dz) = newSeg.shape
    while 2 in newSeg:
        for (x,y,z) in np.argwhere(newSeg == 2):
            newSeg[x,y,z] = 1
            for (i,j,k) in np.ndindex((3,3,3)):
                if 0<=(x+i-1)<dx and 0<=(y+j-1)<dy and 0<=(z+k-1)<dz and surface[x+i-1,y+j-1,z+k-1]>0 and voxel_array[x+i-1,y+j-1,z+k-1]>0 and newSeg[x+i-1,y+j-1,z+k-1]==0 and ref[i,j,k]>0:
                    if (A*(x+i-1)+B*(y+j-1)-(z+k-1)+C)*(A*(px+i-1)+B*(py+j-1)-(pz+k-1)+C)>=0:
                        newSeg[x+i-1,y+j-1,z+k-1] = 2
    return newSeg
    

#Example function for use in mesh mode
#
#Returns an Nx3 numpy array containing N vertices from the input list of vertices
#which represent a random segmentation
#
#To run, use command "py testbench.py examples/example_random.py randomMesh(filename,point,vertices,faces) mesh -r"    
def randomMesh(filename, point, vertices, faces):
    
    #Read true segmentation
    filename = filename.split('\\')[-1].split('_')[0]
    obj = readDataMesh(filename)
    boundaryPath = obj.an_boundary.reshape((-1,3))
    (px,py,pz) = (point[0],point[1],point[2])
    
    #Find best-fit plane for boundary
    (A,B,C) = linalg.lstsq(np.c_[boundaryPath[:,0],boundaryPath[:,1],np.ones(boundaryPath.shape[0])],boundaryPath[:,2])[0]
    
    #Add randomized offset and skew
    offset = (np.random.rand()*2-1)*(obj.anDim.x)/4
    skewA = (1+.1*(np.random.rand()*2-1))
    skewB = (1+.1*(np.random.rand()*2-1))
    (A,B,C) = (A*skewA, B*skewB, C+offset)
    
    #Remove vertices which are on the opposite side of the new plane as the starting vertex
    removeList = []
    for (x,y,z) in obj.graph.nodes():
        if (A*x+B*y-z+C)*(A*px+B*py-pz+C)<0: removeList.append((x,y,z))
    obj.graph.remove_nodes_from(removeList)
    
    #Return remaining vertices which are connected to the starting vertex
    return np.array(list(map(np.array,nx.shortest_path(obj.graph,tuple(point)).keys())))
